function sdRDM = splitDataRDM(patterns_a, patterns_b, varargin)
% sdRDM = splitDataRDM(patterns_a, patterns_b[, distanceMeasure])
%
% patterns_a and patterns_b are both conditions x voxels matrices
%
% distanceMeasure is 'correlation' by default, but can be:
%     'euclidean', ...
%     'seuclidean', ...
%     'cityblock', ...
%     'mahalanobis', ...
%     'minkowski', ...
%     'cosine', ...
%     'correlation', ...
%     'spearman', ...
%     'hamming', ...
%     'jaccard', ...
%     'chebychev'
%
% sdRDM is a split-data RDM

%% Catch errors and setup defaults
if ~isequal(size(patterns_b), size(patterns_a))
    error('Split data inputs matrices must be of the same size.');
end%if
if numel(varargin) == 0
    distanceMeasure = 'correlation';
elseif numel(varargin) == 1 && ischar(varargin{1})
    distanceMeasure = varargin{1};
    
    switch distanceMeasure
        case { ...
                'euclidean', ...
                'seuclidean', ...
                'cityblock', ...
                'mahalanobis', ...
                'minkowski', ...
                'cosine', ...
                'correlation', ...
                'spearman', ...
                'hamming', ...
                'jaccard', ...
                'chebychev' ...
                }
        otherwise
            error('Third argument must be a valid distance measure.')
    end
else
    error('Wrong number of arguments (please use 2 or 3).');
end

[nConditions nVoxels] = size(patterns_a);

dcsRDM = doubleConditionsSetRDM(patterns_a, patterns_b, distanceMeasure);
sdRDM = dcsRDM(nConditions+1:end, 1:nConditions);